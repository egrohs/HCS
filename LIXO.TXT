	// minion? deals damage
	// DONE não confundir! whenever you summon com ":,. (re)?summon"
	// "your (other )?minions", // AoE effect
	// Aoe dmg? adjacent?
	// return an enemy minion to your opponent's hand. // apenas para mão
	// oponente, detectar isso?
	// all minions cost (1) more.
	// your minions cost (1).
	// force an enemy minion to deal its damage to the (minions next to it).//
	// when you play or discard this, deal 4 damage to a random enemy.
	// this minion's attack is always equal to its health.
	// swap the attack and health of all minions.
	// "at the start of your turn, swap this minion with a random one in your hand.",//return
	// hand? hand into the battlefield?
	// your cards and powers that restore health now deal damage instead.
	// put 2 random demons from your deck into your hand.
	// at the end of your turn, add a dream card to your hand.
	// at the start of your turn, restore this minion to full health.
	// also damages the minions next to whomever he attacks.
	// deal damage to each minion equal to its attack.//AoE dmg?
	// restore all characters to full health.
	// add 2 random class cards to your hand (from your opponent's class).
	// whenever you summon a minion, give it (+1/+1) and this loses 1
	// durability.//detectar o +1/+1!
	// "AGRO MINION attack/cost >2",
	// "Low Cost Cards", "Low Cost Minions", "Low Cost Spells",
	// "Low HP Minions",
	// "OTHER DISADVANTAGES",
	// "High Attack Minions", "High Cost Cards", "High HP Minions",
	// MULTI target == (all)
	// "DMG SPELLS",
	static String[] entities = { "character(s)?", "enem(y|ies)", "(hero)? power(s)?", "mana crystal(s)?", "minion(s)?",
			"player(s)?", "secret", "weapon", };

	static Map<String, Double> actions = new HashMap<String, Double>();
	static {
		int att = 5, hp = 5;
		actions.put("( \\-\\d attack)", 1.0);
		actions.put("( \\+\\d attack)", 1.0);
		actions.put("add ", 1.0);
		actions.put("(\\+\\d |double )(\\w\\s)*health", 1.0);
		actions.put("(cost(s)? \\(\\d+\\) less|reduce the cost )", 1.0);
		actions.put("cost(s)? \\(\\d+\\) more", 1.0);
		actions.put("( damage to all )", 1.0);
		actions.put("(destroy all )", 1.0);
		// formula
		actions.put("(mega\\-)?windfury", att * 2.0);
		actions.put("((^|\\: |\\, |\\. )(re)?summon |return it to life)", 1.0);
		actions.put("(take|gain) control of", 1.0);
		actions.put("can\\'t attack", 1.0);
		actions.put("can\\'t be targeted by spells or hero powers", 1.0);
		actions.put("charge", 1.0);
		actions.put("cop(y|ies)", 1.0);
		actions.put("divine shield", hp + 1.0);
		actions.put("draw (\\d+ |a |one |an extra )?", 1.0);
		actions.put("enrage\\:", 1.0);
		actions.put("equip a weapon", 1.0);
		actions.put("freeze ", 1.0);
		actions.put("into the battlefield", 1.0);
		actions.put("immune", 1.0);
		actions.put("inspire", 1.0);
		actions.put("attack the wrong enemy", 1.0);
		actions.put("put ", 1.0);
		actions.put("restore (.+ )+health", 1.0);
		actions.put("return (.+) (your|owner\'s) hand", 1.0);
		actions.put("silence", 1.0);
		actions.put("spell damage \\+\\d+", 1.0);
		actions.put("stealth", 1.0);
		actions.put("swap ", 1.0);
		actions.put("taunt", 1.0);
		actions.put("transform", 1.0);
		actions.put("deal (\\d+ )?damage", 1.0);
		actions.put("destroy ", 1.0);
		actions.put("(double|change|set| become(s)? |gain |has |give |have )", 1.0);
		actions.put("shuffle ", 1.0);
	}

	static String[] targets = { "adjacent", "all ", };

	static Map<String, Double> triggers = new HashMap<String, Double>();
	static {
		/*
		 * TODO deve variar em cada carta. Survability aumenta bastante se vc
		 * tiver algum minion com taunt no campo.
		 */
		double survTurns = 3.0;
		triggers.put("overload", -1.0);
		triggers.put("battlecry", 1.0);
		triggers.put("choose one \\-", 1.0);
		triggers.put("combo\\:", 1.0);
		triggers.put("deathrattle", 1.0);
		// once per your turn
		triggers.put("attacks", survTurns);
		// once per your turn
		triggers.put("at the (start|end) of your", survTurns);
		triggers.put("damaged by", 1 * survTurns);
		// apenas metade é spell
		// triggers.put("(you|opponent|enemy) cast(s)?", 1.5 * survTurns / 2);
		triggers.put("(you|player) cast(s)?", 1.5 * survTurns / 2);
		triggers.put("gain(s)? armor", 1.5 * survTurns);
		// quem?
		triggers.put("( card is played|(you|player) play(s)? a card)", 2 * survTurns);
		// apenas metade é minion
		triggers.put("play(s)? a(.*\\s)? minion", 1.2 * survTurns / 2);
		triggers.put("( you draw )", 1.2 * survTurns);
		triggers.put("( you summon | is summoned)", 1.2 * survTurns);
		// 20 secrets (40 cards), 3 heroes (hunter, mage, paladin), 2 deck (60
		// cards)
		triggers.put("(secret is revealed)", 28 / 60 * survTurns * 2);
		// apenas metade é spell
		// triggers.put("player casts", 1.5 * survTurns * 2 / 2);
		triggers.put("die(s|d)", 1.2 * survTurns * 2);
		triggers.put("( is healed)", 1 * survTurns * 2);
		// triggers.put("( card is played| player plays a card)", 2 * survTurns
		// * 2);
		// apenas metade é minion
		// triggers.put("is summoned)", 1.2 * survTurns * 2 / 2);
		triggers.put("(takes|survives) damage", survTurns);
		// apenas metade é spell
		triggers.put("target this minion with a spell", 1 * survTurns * 2 / 2);
		triggers.put("at the (start|end) of each", 1 * survTurns * 2);
		triggers.put("discard a card", 0.1);// ?
		triggers.put("(after |when(ever)? )", 0.1);// ?
	}


	private static void buildMechanics() {
		mechanics.add(new Mechanic(0, "deal ", "Damage Spells", new int[] { 1 }) {
			public boolean eval(Card c) {
				if (c.type.equals("Spell")) {
					return true;
				}
				return false;
			}
		});
		mechanics.add(new Mechanic(1, "spell damage \\+\\d+", "Spell Damage", new int[] { 0, 25 }));
		mechanics.add(new Mechanic(2, "battlecry:", "Battlecry", new int[] { 3 }));
		mechanics.add(new Mechanic(3, "return", "Return to Hand", new int[] { 2, 9, 10, 11, 29, 37 }));
		// mechanics.add(new Mechanic(4, "(\\+|\\-)\\(?\\d+\\)?\\%?",
		// "Buff Stats", new int[] { 5, 11, 32, 35, 37 }));
		mechanics.add(new Mechanic(4, "( die(s|d))", "Necrofilo", new int[] { 9, 16 }));
		mechanics.add(new Mechanic(5, "(mega\\-)?windfury", "Windfury", new int[] { 8, 11 }));
		mechanics.add(new Mechanic(6, "can\\'t attack", "Can't Attack", new int[] { 7, 25 }));
		mechanics.add(new Mechanic(7, "silence", "Silence", new int[] { 6 }));
		// mechanics.add(new Mechanic(8, "(double|change|set| become(s)?)",
		// "Change Stats", new int[] { 10 }));
		mechanics.add(new Mechanic(8, "(double .*| \\+\\d+) attack", "+ Attack", new int[] { 5, 11 }));
		mechanics.add(new Mechanic(9, "destroy all", "Destroy All", new int[] { 3, 4, 17 }));
		mechanics.add(new Mechanic(10, "control", "Control", new int[] { 3 }));
		mechanics.add(new Mechanic(11, "charge", "Charge", new int[] { 3, 8, 5, 24 }));
		mechanics.add(new Mechanic(12, "combo:", "Combo", new int[] { 13 }));
		mechanics.add(new Mechanic(13, ".*", "Low Cost Cards", new int[] { 12, 20 }) {
			public boolean eval(Card c) {
				if (c.cost < 4) {
					return true;
				}
				return false;
			}
		});
		mechanics.add(new Mechanic(14, "copy", "Copy", new int[] { 15 }));
		mechanics.add(new Mechanic(15, ".*", "High Cost Cards", new int[] { 14, 29 }) {
			public boolean eval(Card c) {
				if (c.cost > 5) {
					return true;
				}
				return false;
			}
		});
		mechanics.add(new Mechanic(16, "damage to all", "Damage All", new int[] { 4, 17, 28, 33 }));
		// TODO deathrattle combina com deathrattle
		mechanics.add(new Mechanic(17, "deathrattle(:|s)?", "Deathrattle", new int[] { 9, 16, 24 }));
		mechanics.add(new Mechanic(18, ".*", "High HP Minions", new int[] { 23, 25, 32, 36 }) {
			public boolean eval(Card c) {
				if (c.type.equals("Minion") && c.health > 5) {
					return true;
				}
				return false;
			}
		});
		mechanics.add(new Mechanic(19, "divine shield", "Divine Shield", new int[] { 9, 27 }));
		mechanics.add(new Mechanic(20, "draw (\\d+|a)", "Draw Cards", new int[] { 13 }));
		mechanics.add(new Mechanic(21, "enrage", "Enrage", new int[] { 22 }));
		mechanics.add(new Mechanic(22, "( you summon | is summoned)", "Summoning", new int[] { 20, 24, 37 }));
		// TODO como fazer o if < 3 ??
		// mechanics.add(new Mechanic(22, "deal \\d+ && x < 3",
		// "Low Dmg Low Attack", new int[] { 21, 28 }) {
		// public boolean eval(Card c) {
		// if (c.attack != null && c.attack < 3) {
		// return true;
		// }
		// return false;
		// }
		// });
		mechanics.add(new Mechanic(23, "restore", "Restore Health", new int[] { 18, 28 }));
		mechanics.add(new Mechanic(24, "(re)?summon ", "Invoca", new int[] { 11, 17, 22, 31 }));
		mechanics.add(new Mechanic(25, "taunt", "Taunt", new int[] { 1, 6, 18 }));
		mechanics.add(new Mechanic(26, "transform", "Transform", new int[] { 37, 39 }));
		mechanics.add(new Mechanic(27, ".*", "Low HP Minions", new int[] { 19, 33, 35 }) {
			public boolean eval(Card c) {
				if (c.type.equals("Minion") && c.health < 4) {
					return true;
				}
				return false;
			}
		});
		mechanics.add(new Mechanic(28, " (takes|survives) damage", "Masoquista", new int[] { 16, 23 }));
		mechanics.add(new Mechanic(29, " cost(s)? \\(\\d+\\) less", "Cost Less", new int[] { 3, 13, 15, 38 }));
		// mechanics.add(new Mechanic(30, "all (other )?enemies",
		// "Damage Enemies", new int[] { 27 }));
		mechanics.add(new Mechanic(30, "(all |your )(other |enemy |friendly |non-Demon )?(minions|characters)",
				"Multi target", new int[] {}));
		mechanics.add(new Mechanic(31, "(is summoned| you summon )", "Is Summoned", new int[] { 24 }));
		mechanics.add(new Mechanic(32, "(give|have)", "Grant", new int[] { 8, 18, 35 }));
		mechanics.add(new Mechanic(33, "immune", "Immune", new int[] { 16, 27 }));
		// mechanics.add(new Mechanic(34, " mana crystal(s)", "Mana Crystal",
		// new int[] { }));
		// mechanics.add(new Mechanic(34, ".*", "High Attack Minions", new int[]
		// { 33 }) {
		// public boolean eval(Card c) {
		// if (c.attack != null && c.attack > 5) {
		// return true;
		// }
		// return false;
		// }
		// });
		mechanics.add(new Mechanic(35, "stealth", "Stealth", new int[] { 27, 32, 36 }));
		mechanics.add(new Mechanic(36, "(after |at the end of |at the start of | damaged by |when(ever)? )",
				"Perma Trigger Minions", new int[] { 18, 35 }) {
			public boolean eval(Card c) {
				if (!c.type.equals("Spell")) {
					return true;
				}
				return false;
			}
		});
		mechanics.add(new Mechanic(37, ".*", "Low Cost Minions", new int[] { 3, 8, 22, 26 }) {
			public boolean eval(Card c) {
				if (c.type.equals("Minion") && c.cost < 4) {
					return true;
				}
				return false;
			}
		});
		mechanics.add(new Mechanic(38, ".*", "Low Cost Spells", new int[] { 29 }) {
			public boolean eval(Card c) {
				if (c.type.equals("Spell") && c.cost < 4) {
					return true;
				}
				return false;
			}
		});
		mechanics.add(new Mechanic(39, "choose one", "Choose One", new int[] { 26 }));
		mechanics.add(new Mechanic(40, "can\'t be target", "Shroud", new int[] {}));
		mechanics.add(new Mechanic(41, "secret:", "Secret", new int[] {}));
		mechanics.add(new Mechanic(42, "equip ", "Equip Weapon", new int[] {}));
		mechanics.add(new Mechanic(43, ".*", "Weapon", new int[] {}) {
			public boolean eval(Card c) {
				if (c.type.equals("Weapon")) {
					return true;
				}
				return false;
			}
		});
		mechanics.add(new Mechanic(44, "freeze", "Freeze", new int[] {}));
		mechanics.add(new Mechanic(45, "from your deck into your hand", "Tutor", new int[] {}));
		for (Mechanic m : mechanics) {
			m.setSinergy();
		}
		mechanics.add(new Mechanic(46, "inspire:", "Inspire", new int[] {}));
	}
	
	private static void parseCards() {
		for (Card c : cards) {
			for (String m : actions.keySet()) {
				if (c.text != null) {
					Matcher ma = Pattern.compile(m).matcher(c.text);
					if (ma.find()) {
						c.actions.add(m);
					}
				}
			}
			for (String m : triggers.keySet()) {
				if (c.text != null) {
					Matcher ma = Pattern.compile(m).matcher(c.text);
					if (ma.find()) {
						c.triggers.add(m);
					}
				}
			}
			for (String m : entities) {
				if (c.text != null) {
					Matcher ma = Pattern.compile(m).matcher(c.text);
					if (ma.find()) {
						c.entities.add(m);
					}
				}
			}
			for (String m : targets) {
				if (c.text != null) {
					Matcher ma = Pattern.compile(m).matcher(c.text);
					if (ma.find()) {
						c.targets.add(m);
					}
				}
			}
		}
	}